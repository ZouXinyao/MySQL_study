# 事务处理

是进行一次处理的基本单元，要么完全执行，要么都不执行。如果我们在增加、删除、修改的时候某一个环节出了错，它允许我们回滚还原。

一、事务特性

- A，也就是原子性（Atomicity）。原子的概念就是不可分割，可以理解为组成物质的基本单位，也是我们进行数据处理操作的基本单位。
- C，就是一致性（Consistency）。一致性指的就是数据库在进行事务操作后，会由原来的一致状态，变成另一种一致的状态。也就是说当事务提交后，或者当事务发生回滚后，数据库的完整性约束不能被破坏。
- I，就是隔离性（Isolation）。它指的是每个事务都是彼此独立的，不会受到其他事务的执行影响。
- D，指的是持久性（Durability）。事务提交之后对数据的修改是持久性的，即使在系统出故障的情况下，比如系统崩溃或者存储介质发生故障，数据的修改依然是有效的。

二、事务的控制语句

1、控制语句

- START TRANSACTION 或者 BEGIN，作用是显式开启一个事务。
- COMMIT：提交事务。当提交事务后，对数据库的修改是永久性的。
- ROLLBACK 或者 ROLLBACK TO [SAVEPOINT]，意为回滚事务。意思是撤销正在进行的所有没有提交的修改，或者将事务回滚到某个保存点。
- SAVEPOINT：在事务中创建保存点，方便后续针对保存点进行回滚。一个事务中可以存在多个保存点。
- RELEASE SAVEPOINT：删除某个保存点。
- SET TRANSACTION，设置事务的隔离级别。

显式事务与隐式事务：隐式事务就是自动提交。

2、举例

```
CREATE TABLE test(name varchar(255), PRIMARY KEY (name)) ENGINE=InnoDB;
BEGIN;
INSERT INTO test SELECT '关羽';
COMMIT;
INSERT INTO test SELECT '张飞';
INSERT INTO test SELECT '张飞';
ROLLBACK;
SELECT * FROM test;
```

运行时，会把'关羽''张飞'都插入到表中，但是第二次插入“张飞”就会报错。最后在执行 ROLLBACK 的时候，插入第一个‘张飞’的事务已经自动提交了，就没法进行回滚了。

3、MySQL 中 completion_type 参数的作用：

- completion=0，这是默认情况。也就是说当我们执行 COMMIT 的时候会提交事务，在执行下一个事务时，还需要我们使用 START TRANSACTION 或者 BEGIN 来开启。
- completion=1，这种情况下，当我们提交事务后，相当于执行了 COMMIT AND CHAIN，也就是开启一个链式事务，即当我们提交事务之后会开启一个相同隔离级别的事务（隔离级别会在下一节中进行介绍）。
- completion=2，这种情况下 COMMIT=COMMIT AND RELEASE，也就是当我们提交后，会自动与服务器断开连接。

4、autocommit的使用

 autocommit=0 时，不论是否采用 START TRANSACTION 或者 BEGIN 的方式来开启事务，都需要用 COMMIT 进行提交，让事务生效，使用 ROLLBACK 对事务进行回滚。

当我们设置 autocommit=1 时，每条 SQL 语句都会自动进行提交；如果用 START TRANSACTION 或者 BEGIN 的方式来显式地开启事务，那么这个事务只有在 COMMIT 时才会生效，在 ROLLBACK 时才会回滚。

三、事务隔离

可以防止数据库在并发处理时出现数据不一致的情况，但是高并发的情况下，每个事务都隔离，性能损失过大，所以需要通过设置不同的隔离等级，以便在正确性和效率之间进行平衡。

1、事务并发处理可能产生的异常

- 脏读：事务没有提交，但是另一个读进程已经读到了数据
- 不可重复读：进程1第一次读数据A，这时进程2将数据A改成了B，进程1再一次读的时候发现数据变成B了。(进程1的两次读都是相同的查询)
- 幻读：进程1第一次读表得到数据A，这时进程2添加了点数据，表里数据变成A1了，进程1有查询了一次，数据多了，变成A1了(两次查询个数的改变)

另一种说法：

- 脏读：读到了其他事务还没有提交的数据。
- 不可重复读：对某数据进行读取，发现两次读取的结果不同，也就是说没有读到相同的内容。这是因为有其他事务对这个数据同时进行了修改或删除。
- 幻读：事务 A 根据条件查询得到了 N 条数据，但此时事务 B 更改或者增加了 M 条符合事务 A 查询条件的数据，这样当事务 A 再次进行查询的时候发现会有 N+M 条数据，产生了幻读。

2、4中隔离级别

从低到高依次是：读未提交、读已提交、可重复读和可串行化。

能解决的问题有：

|          | 脏读   | 不可重复读 | 幻读   |
| -------- | ------ | ---------- | ------ |
| 读未提交 | 未解决 | 未解决     | 未解决 |
| 读已提交 | 解决   | 未解决     | 未解决 |
| 可重复读 | 解决   | 解决       | 未解决 |
| 可串行化 | 解决   | 解决       | 解决   |

可串行化可以避免所有异常，读未提交都无法避免。

- 读未提交，也就是允许读到未提交的数据，这种情况下查询是不会使用锁。
- 读已提交就是只能读到已经提交的内容，可以避免脏读的产生，属于 RDBMS 中常见的默认隔离级别，但如果想要避免不可重复读或者幻读，需要加锁。
- 可重复读，保证一个事务在相同查询条件下两次查询得到的数据结果是一致的，可以避免不可重复读和脏读，但无法避免幻读。MySQL 默认的隔离级别就是可重复读。
- 可串行化，将事务进行串行化，也就是在一个队列中按照顺序执行，它牺牲了系统的并发性。

隔离级别越低，意味着系统吞吐量（并发程度）越大，但同时也意味着出现异常问题的可能性会更大。应该根据具体的业务场景，在正确性上和性能上进行取舍。













